#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 4 21700
    bytecblock "listings" "listings1" 0x151f7c75
    // smart_contracts/t_uno/contract.algo.ts:72
    // export class TicketingPlatform extends arc4.Contract {
    txn NumAppArgs
    bz main_bare_routing@21
    pushbytess 0x80ab2b8a 0x6509dd8c 0x7c5b0289 0xb5efc596 0xa2f708d4 0x17460294 0x3c829d94 0x2d43cdac 0xdbb5bc19 0x009a1593 0x58f7ef14 0x0f77963b 0x7ec2dd16 0xb80480a6 0x27009b89 0x6c340e44 // method "listingBoxMbr()uint64", method "freeListingBoxMbr()uint64", method "balance()uint64", method "mintNft(account,string,string)uint64", method "optInToAsset(asset,pay)void", method "newListing(axfer,uint64,pay)void", method "newListingFreeAccess(axfer,uint64,uint64,uint64,pay)void", method "changePrice(asset,uint64)void", method "changePriceFreeAccess(asset,uint64,uint64)void", method "deposit(uint64,asset,uint64)void", method "buy(asset,pay)void", method "buyFreeAccessTicket(asset,address,uint64,uint64,pay)void", method "withdrawAsset(asset)void", method "withdrawFreeAccessTickets(asset,uint64,uint64)void", method "buyWithAssets(asset,axfer)void", method "isOptedInTo(asset)bool"
    txna ApplicationArgs 0
    match main_listingBoxMbr_route@3 main_freeListingBoxMbr_route@4 main_balance_route@5 main_mintNft_route@6 main_optInToAsset_route@7 main_newListing_route@8 main_newListingFreeAccess_route@9 main_changePrice_route@10 main_changePriceFreeAccess_route@11 main_deposit_route@12 main_buy_route@13 main_buyFreeAccessTicket_route@14 main_withdrawAsset_route@15 main_withdrawFreeAccessTickets_route@16 main_buyWithAssets_route@17 main_isOptedInTo_route@18

main_after_if_else@25:
    // smart_contracts/t_uno/contract.algo.ts:72
    // export class TicketingPlatform extends arc4.Contract {
    intc_1 // 0
    return

main_isOptedInTo_route@18:
    // smart_contracts/t_uno/contract.algo.ts:507
    // public isOptedInTo(asset: Asset): boolean {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/t_uno/contract.algo.ts:72
    // export class TicketingPlatform extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    // smart_contracts/t_uno/contract.algo.ts:507
    // public isOptedInTo(asset: Asset): boolean {
    callsub isOptedInTo
    pushbytes 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_buyWithAssets_route@17:
    // smart_contracts/t_uno/contract.algo.ts:459
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/t_uno/contract.algo.ts:72
    // export class TicketingPlatform extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/t_uno/contract.algo.ts:459
    // @arc4.abimethod()
    callsub buyWithAssets
    intc_0 // 1
    return

main_withdrawFreeAccessTickets_route@16:
    // smart_contracts/t_uno/contract.algo.ts:426
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/t_uno/contract.algo.ts:72
    // export class TicketingPlatform extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/t_uno/contract.algo.ts:426
    // @arc4.abimethod()
    callsub withdrawFreeAccessTickets
    intc_0 // 1
    return

main_withdrawAsset_route@15:
    // smart_contracts/t_uno/contract.algo.ts:391
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/t_uno/contract.algo.ts:72
    // export class TicketingPlatform extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    // smart_contracts/t_uno/contract.algo.ts:391
    // @arc4.abimethod()
    callsub withdrawAsset
    intc_0 // 1
    return

main_buyFreeAccessTicket_route@14:
    // smart_contracts/t_uno/contract.algo.ts:357
    // public buyFreeAccessTicket(asset: Asset, owner: arc4.Address, nonce: arc4.UintN64, quantity: arc4.UintN64, payment: gtxn.PaymentTxn): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/t_uno/contract.algo.ts:72
    // export class TicketingPlatform extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/t_uno/contract.algo.ts:357
    // public buyFreeAccessTicket(asset: Asset, owner: arc4.Address, nonce: arc4.UintN64, quantity: arc4.UintN64, payment: gtxn.PaymentTxn): void {
    callsub buyFreeAccessTicket
    intc_0 // 1
    return

main_buy_route@13:
    // smart_contracts/t_uno/contract.algo.ts:301
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/t_uno/contract.algo.ts:72
    // export class TicketingPlatform extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/t_uno/contract.algo.ts:301
    // @arc4.abimethod()
    callsub buy
    intc_0 // 1
    return

main_deposit_route@12:
    // smart_contracts/t_uno/contract.algo.ts:279
    // public deposit(quantity: arc4.UintN64, asset: Asset, nonce: arc4.UintN64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/t_uno/contract.algo.ts:72
    // export class TicketingPlatform extends arc4.Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txnas Assets
    txna ApplicationArgs 3
    // smart_contracts/t_uno/contract.algo.ts:279
    // public deposit(quantity: arc4.UintN64, asset: Asset, nonce: arc4.UintN64): void {
    callsub deposit
    intc_0 // 1
    return

main_changePriceFreeAccess_route@11:
    // smart_contracts/t_uno/contract.algo.ts:256
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/t_uno/contract.algo.ts:72
    // export class TicketingPlatform extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/t_uno/contract.algo.ts:256
    // @arc4.abimethod()
    callsub changePriceFreeAccess
    intc_0 // 1
    return

main_changePrice_route@10:
    // smart_contracts/t_uno/contract.algo.ts:229
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/t_uno/contract.algo.ts:72
    // export class TicketingPlatform extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    // smart_contracts/t_uno/contract.algo.ts:229
    // @arc4.abimethod()
    callsub changePrice
    intc_0 // 1
    return

main_newListingFreeAccess_route@9:
    // smart_contracts/t_uno/contract.algo.ts:186
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/t_uno/contract.algo.ts:72
    // export class TicketingPlatform extends arc4.Contract {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/t_uno/contract.algo.ts:186
    // @arc4.abimethod()
    callsub newListingFreeAccess
    intc_0 // 1
    return

main_newListing_route@8:
    // smart_contracts/t_uno/contract.algo.ts:150
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/t_uno/contract.algo.ts:72
    // export class TicketingPlatform extends arc4.Contract {
    txn GroupIndex
    pushint 2 // 2
    -
    dup
    gtxns TypeEnum
    intc_2 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/t_uno/contract.algo.ts:150
    // @arc4.abimethod()
    callsub newListing
    intc_0 // 1
    return

main_optInToAsset_route@7:
    // smart_contracts/t_uno/contract.algo.ts:128
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/t_uno/contract.algo.ts:72
    // export class TicketingPlatform extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/t_uno/contract.algo.ts:128
    // @arc4.abimethod()
    callsub optInToAsset
    intc_0 // 1
    return

main_mintNft_route@6:
    // smart_contracts/t_uno/contract.algo.ts:102
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/t_uno/contract.algo.ts:72
    // export class TicketingPlatform extends arc4.Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    // smart_contracts/t_uno/contract.algo.ts:102
    // @arc4.abimethod()
    callsub mintNft
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_balance_route@5:
    // smart_contracts/t_uno/contract.algo.ts:96
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub balance
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_freeListingBoxMbr_route@4:
    // smart_contracts/t_uno/contract.algo.ts:86
    // freeListingBoxMbr(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c750000000000006dc4
    log
    intc_0 // 1
    return

main_listingBoxMbr_route@3:
    // smart_contracts/t_uno/contract.algo.ts:78
    // listingBoxMbr(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    pushbytes 0x151f7c7500000000000054c4
    log
    intc_0 // 1
    return

main_bare_routing@21:
    // smart_contracts/t_uno/contract.algo.ts:72
    // export class TicketingPlatform extends arc4.Contract {
    txn OnCompletion
    bnz main_after_if_else@25
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// smart_contracts/t_uno/contract.algo.ts::TicketingPlatform.balance() -> uint64:
balance:
    // smart_contracts/t_uno/contract.algo.ts:98
    // const [balance, exists] = op.AcctParams.acctBalance(Global.currentApplicationAddress);
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    pop
    // smart_contracts/t_uno/contract.algo.ts:99
    // return balance;
    retsub


// smart_contracts/t_uno/contract.algo.ts::TicketingPlatform.mintNft(sender: bytes, assetName: bytes, ticket_link: bytes) -> uint64:
mintNft:
    // smart_contracts/t_uno/contract.algo.ts:102-103
    // @arc4.abimethod()
    // public mintNft(sender: Account, assetName: string, ticket_link: string): uint64{
    proto 3 1
    // smart_contracts/t_uno/contract.algo.ts:104-115
    // const result = itxn.assetConfig({
    //   sender: sender,
    //   assetName: assetName,
    //   url: ticket_link,
    //   total: 1,
    //   decimals: 0,
    //   manager: Txn.sender,
    //   reserve: Txn.sender,
    //   freeze: Txn.sender,
    //   clawback: Txn.sender,
    //   fee: Global.minTxnFee
    // }).submit();
    itxn_begin
    // smart_contracts/t_uno/contract.algo.ts:114
    // fee: Global.minTxnFee
    global MinTxnFee
    // smart_contracts/t_uno/contract.algo.ts:110
    // manager: Txn.sender,
    txn Sender
    // smart_contracts/t_uno/contract.algo.ts:111-113
    // reserve: Txn.sender,
    // freeze: Txn.sender,
    // clawback: Txn.sender,
    dupn 3
    itxn_field ConfigAssetClawback
    itxn_field ConfigAssetFreeze
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    // smart_contracts/t_uno/contract.algo.ts:109
    // decimals: 0,
    intc_1 // 0
    itxn_field ConfigAssetDecimals
    // smart_contracts/t_uno/contract.algo.ts:108
    // total: 1,
    intc_0 // 1
    itxn_field ConfigAssetTotal
    frame_dig -1
    itxn_field ConfigAssetURL
    frame_dig -2
    itxn_field ConfigAssetName
    frame_dig -3
    itxn_field Sender
    // smart_contracts/t_uno/contract.algo.ts:104-115
    // const result = itxn.assetConfig({
    //   sender: sender,
    //   assetName: assetName,
    //   url: ticket_link,
    //   total: 1,
    //   decimals: 0,
    //   manager: Txn.sender,
    //   reserve: Txn.sender,
    //   freeze: Txn.sender,
    //   clawback: Txn.sender,
    //   fee: Global.minTxnFee
    // }).submit();
    pushint 3 // 3
    itxn_field TypeEnum
    itxn_field Fee
    itxn_submit
    itxn CreatedAssetID
    // smart_contracts/t_uno/contract.algo.ts:117
    // return result.createdAsset.id;
    retsub


// smart_contracts/t_uno/contract.algo.ts::TicketingPlatform.optInToAsset(asset: uint64, mbrPay: uint64) -> void:
optInToAsset:
    // smart_contracts/t_uno/contract.algo.ts:128-129
    // @arc4.abimethod()
    // public optInToAsset(asset: Asset, mbrPay: gtxn.PaymentTxn): void {
    proto 2 0
    // smart_contracts/t_uno/contract.algo.ts:133
    // assert(!Global.currentApplicationAddress.isOptedIn(asset));
    global CurrentApplicationAddress
    frame_dig -2
    asset_holding_get AssetBalance
    bury 1
    !
    assert
    // smart_contracts/t_uno/contract.algo.ts:135
    // assert(mbrPay.receiver===Global.currentApplicationAddress);
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert
    // smart_contracts/t_uno/contract.algo.ts:136
    // assert(mbrPay.amount===Global.assetOptInMinBalance)
    frame_dig -1
    gtxns Amount
    global AssetOptInMinBalance
    ==
    assert
    // smart_contracts/t_uno/contract.algo.ts:140-145
    // itxn.assetTransfer({
    //   xferAsset: asset,
    //   assetSender: Global.callerApplicationAddress,
    //   assetReceiver: Global.currentApplicationAddress,
    //   assetAmount: 0,
    // }).submit();
    itxn_begin
    // smart_contracts/t_uno/contract.algo.ts:142
    // assetSender: Global.callerApplicationAddress,
    global CallerApplicationAddress
    // smart_contracts/t_uno/contract.algo.ts:143
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/t_uno/contract.algo.ts:144
    // assetAmount: 0,
    intc_1 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field AssetSender
    frame_dig -2
    itxn_field XferAsset
    // smart_contracts/t_uno/contract.algo.ts:140-145
    // itxn.assetTransfer({
    //   xferAsset: asset,
    //   assetSender: Global.callerApplicationAddress,
    //   assetReceiver: Global.currentApplicationAddress,
    //   assetAmount: 0,
    // }).submit();
    intc_2 // 4
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    retsub


// smart_contracts/t_uno/contract.algo.ts::TicketingPlatform.newListing(xfer: uint64, unitaryPrice: bytes, mbrPay: uint64) -> void:
newListing:
    // smart_contracts/t_uno/contract.algo.ts:150-151
    // @arc4.abimethod()
    // public newListing(xfer: gtxn.AssetTransferTxn, unitaryPrice: arc4.UintN64, mbrPay: gtxn.PaymentTxn): void {
    proto 3 0
    // smart_contracts/t_uno/contract.algo.ts:157
    // assert(unitaryPrice.native > 0);
    frame_dig -2
    btoi
    assert
    // smart_contracts/t_uno/contract.algo.ts:161
    // asset: new arc4.UintN64(xfer.xferAsset.id)
    frame_dig -3
    gtxns XferAsset
    itob
    // smart_contracts/t_uno/contract.algo.ts:75
    // assignedTicketlistings = BoxMap<AssignedTicketKey, AssignedTicketValue>({keyPrefix: 'listings'});
    bytec_0 // "listings"
    swap
    concat
    // smart_contracts/t_uno/contract.algo.ts:165
    // assert(!this.assignedTicketlistings(key).exists, 'Listing for asset already exists');
    dup
    box_len
    bury 1
    !
    assert // Listing for asset already exists
    // smart_contracts/t_uno/contract.algo.ts:168
    // assert(Global.currentApplicationId.address===mbrPay.receiver, 'Receiver for payment is not the application');
    global CurrentApplicationID
    app_params_get AppAddress
    assert // application exists
    frame_dig -1
    gtxns Receiver
    ==
    assert // Receiver for payment is not the application
    // smart_contracts/t_uno/contract.algo.ts:171
    // assert(mbrPay.amount>=this.listingBoxMbr(), 'Insufficient funds to create listing')
    frame_dig -1
    gtxns Amount
    // smart_contracts/t_uno/contract.algo.ts:80-82
    // 2_500 + (
    //   4_00 * 48
    // )
    intc_3 // 21700
    // smart_contracts/t_uno/contract.algo.ts:171
    // assert(mbrPay.amount>=this.listingBoxMbr(), 'Insufficient funds to create listing')
    >=
    assert // Insufficient funds to create listing
    // smart_contracts/t_uno/contract.algo.ts:174
    // assert(xfer.assetReceiver===Global.currentApplicationId.address, 'Asset receiver is not the application');
    frame_dig -3
    gtxns AssetReceiver
    global CurrentApplicationID
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Asset receiver is not the application
    // smart_contracts/t_uno/contract.algo.ts:175
    // assert(xfer.assetAmount===1, 'Asset must be unique');
    frame_dig -3
    gtxns AssetAmount
    intc_0 // 1
    ==
    assert // Asset must be unique
    // smart_contracts/t_uno/contract.algo.ts:181
    // owner: new arc4.Address(Txn.sender),
    txn Sender
    // smart_contracts/t_uno/contract.algo.ts:180-183
    // this.assignedTicketlistings(key).value = new AssignedTicketValue({
    //   owner: new arc4.Address(Txn.sender),
    //   unitaryPrice: unitaryPrice
    // })
    frame_dig -2
    concat
    box_put
    retsub


// smart_contracts/t_uno/contract.algo.ts::TicketingPlatform.newListingFreeAccess(xfer: uint64, quantity: bytes, price: bytes, nonce: bytes, mbrPay: uint64) -> void:
newListingFreeAccess:
    // smart_contracts/t_uno/contract.algo.ts:186-187
    // @arc4.abimethod()
    // public newListingFreeAccess(xfer: gtxn.AssetTransferTxn, quantity: arc4.UintN64, price: arc4.UintN64, nonce: arc4.UintN64, mbrPay: gtxn.PaymentTxn) : void {
    proto 5 0
    // smart_contracts/t_uno/contract.algo.ts:192
    // assert(price.native > 0);
    frame_dig -3
    btoi
    assert
    // smart_contracts/t_uno/contract.algo.ts:195
    // assert(quantity.native > 0);
    frame_dig -4
    btoi
    assert
    // smart_contracts/t_uno/contract.algo.ts:199
    // asset: new arc4.UintN64(xfer.xferAsset.id),
    frame_dig -5
    gtxns XferAsset
    itob
    // smart_contracts/t_uno/contract.algo.ts:200
    // owner: new arc4.Address(xfer.assetSender),
    frame_dig -5
    gtxns AssetSender
    // smart_contracts/t_uno/contract.algo.ts:197-203
    // const key = new FreeAccessTicketKey(
    //   {
    //     asset: new arc4.UintN64(xfer.xferAsset.id),
    //     owner: new arc4.Address(xfer.assetSender),
    //     nonce: nonce
    //   }
    // );
    concat
    frame_dig -2
    concat
    // smart_contracts/t_uno/contract.algo.ts:76
    // freeAcessTicketlisings = BoxMap<FreeAccessTicketKey, FreeAccessTicketValue>({keyPrefix: 'listings1'});
    bytec_1 // "listings1"
    swap
    concat
    // smart_contracts/t_uno/contract.algo.ts:206
    // assert(!this.freeAcessTicketlisings(key).exists);
    dup
    box_len
    bury 1
    !
    assert
    // smart_contracts/t_uno/contract.algo.ts:209
    // assert(Global.currentApplicationId.address===mbrPay.receiver);
    global CurrentApplicationID
    app_params_get AppAddress
    assert // application exists
    frame_dig -1
    gtxns Receiver
    ==
    assert
    // smart_contracts/t_uno/contract.algo.ts:212
    // assert(this.freeListingBoxMbr()===mbrPay.amount)
    frame_dig -1
    gtxns Amount
    // smart_contracts/t_uno/contract.algo.ts:88-90
    // 2_500 + (
    //   4_00 * 64
    // )
    pushint 28100 // 28100
    // smart_contracts/t_uno/contract.algo.ts:212
    // assert(this.freeListingBoxMbr()===mbrPay.amount)
    ==
    assert
    // smart_contracts/t_uno/contract.algo.ts:215
    // assert(xfer.assetReceiver===Global.currentApplicationId.address);
    frame_dig -5
    gtxns AssetReceiver
    global CurrentApplicationID
    app_params_get AppAddress
    assert // application exists
    ==
    assert
    // smart_contracts/t_uno/contract.algo.ts:219-222
    // this.freeAcessTicketlisings(key).value = new FreeAccessTicketValue({
    //   quantity: quantity,
    //   unitaryPrice: price
    // })
    frame_dig -4
    frame_dig -3
    concat
    box_put
    retsub


// smart_contracts/t_uno/contract.algo.ts::TicketingPlatform.changePrice(asset: uint64, newPrice: bytes) -> void:
changePrice:
    // smart_contracts/t_uno/contract.algo.ts:229-230
    // @arc4.abimethod()
    // public changePrice(asset: Asset, newPrice: arc4.UintN64): void {
    proto 2 0
    // smart_contracts/t_uno/contract.algo.ts:233
    // assert(newPrice.native > 0, 'Price cannot be negative');
    frame_dig -1
    btoi
    assert // Price cannot be negative
    // smart_contracts/t_uno/contract.algo.ts:237
    // asset: new arc4.UintN64(asset.id)
    frame_dig -2
    itob
    // smart_contracts/t_uno/contract.algo.ts:75
    // assignedTicketlistings = BoxMap<AssignedTicketKey, AssignedTicketValue>({keyPrefix: 'listings'});
    bytec_0 // "listings"
    swap
    concat
    // smart_contracts/t_uno/contract.algo.ts:240
    // assert(this.assignedTicketlistings(key).exists===true, 'Listing for given asset does not exist');
    dup
    box_len
    bury 1
    intc_0 // 1
    ==
    assert // Listing for given asset does not exist
    // smart_contracts/t_uno/contract.algo.ts:244
    // assert(listing.value.owner.native === Txn.sender, 'Only the owner of this listing can change its price');
    dup
    box_get
    assert // Box must have value
    extract 0 32 // on error: Index access is out of bounds
    txn Sender
    ==
    assert // Only the owner of this listing can change its price
    // smart_contracts/t_uno/contract.algo.ts:248
    // owner: new arc4.Address(Txn.sender),
    txn Sender
    // smart_contracts/t_uno/contract.algo.ts:247-250
    // this.assignedTicketlistings(key).value = new AssignedTicketValue({
    //   owner: new arc4.Address(Txn.sender),
    //   unitaryPrice: newPrice //sovrascrizione prezzo
    // });
    frame_dig -1
    concat
    box_put
    retsub


// smart_contracts/t_uno/contract.algo.ts::TicketingPlatform.changePriceFreeAccess(asset: uint64, nonce: bytes, newPrice: bytes) -> void:
changePriceFreeAccess:
    // smart_contracts/t_uno/contract.algo.ts:256-257
    // @arc4.abimethod()
    // public changePriceFreeAccess(asset: Asset, nonce: arc4.UintN64, newPrice: arc4.UintN64): void {
    proto 3 0
    // smart_contracts/t_uno/contract.algo.ts:259
    // assert(newPrice.native > 0);
    frame_dig -1
    btoi
    assert
    // smart_contracts/t_uno/contract.algo.ts:264
    // asset: new arc4.UintN64(asset.id),
    frame_dig -3
    itob
    // smart_contracts/t_uno/contract.algo.ts:265
    // owner: new arc4.Address(Txn.sender),
    txn Sender
    // smart_contracts/t_uno/contract.algo.ts:263-267
    // const key = new FreeAccessTicketKey({
    //   asset: new arc4.UintN64(asset.id),
    //   owner: new arc4.Address(Txn.sender),
    //   nonce: nonce
    // })
    concat
    frame_dig -2
    concat
    // smart_contracts/t_uno/contract.algo.ts:76
    // freeAcessTicketlisings = BoxMap<FreeAccessTicketKey, FreeAccessTicketValue>({keyPrefix: 'listings1'});
    bytec_1 // "listings1"
    swap
    concat
    // smart_contracts/t_uno/contract.algo.ts:269
    // assert(this.freeAcessTicketlisings(key).exists, 'you do not posess a listing for this asset');
    dup
    box_len
    bury 1
    assert // you do not posess a listing for this asset
    // smart_contracts/t_uno/contract.algo.ts:271
    // const value = this.freeAcessTicketlisings(key).value.copy();
    dup
    box_get
    assert // Box must have value
    // smart_contracts/t_uno/contract.algo.ts:274
    // quantity: value.quantity,
    extract 0 8 // on error: Index access is out of bounds
    // smart_contracts/t_uno/contract.algo.ts:273-276
    //  this.freeAcessTicketlisings(key).value = new FreeAccessTicketValue({
    //   quantity: value.quantity,
    //   unitaryPrice: newPrice
    // })
    frame_dig -1
    concat
    box_put
    retsub


// smart_contracts/t_uno/contract.algo.ts::TicketingPlatform.deposit(quantity: bytes, asset: uint64, nonce: bytes) -> void:
deposit:
    // smart_contracts/t_uno/contract.algo.ts:279
    // public deposit(quantity: arc4.UintN64, asset: Asset, nonce: arc4.UintN64): void {
    proto 3 0
    // smart_contracts/t_uno/contract.algo.ts:284
    // asset: new arc4.UintN64(asset.id),
    frame_dig -2
    itob
    // smart_contracts/t_uno/contract.algo.ts:285
    // owner: new arc4.Address(Txn.sender),
    txn Sender
    // smart_contracts/t_uno/contract.algo.ts:283-287
    // const key = new FreeAccessTicketKey({
    //   asset: new arc4.UintN64(asset.id),
    //   owner: new arc4.Address(Txn.sender),
    //   nonce: nonce
    // })
    concat
    frame_dig -1
    concat
    // smart_contracts/t_uno/contract.algo.ts:76
    // freeAcessTicketlisings = BoxMap<FreeAccessTicketKey, FreeAccessTicketValue>({keyPrefix: 'listings1'});
    bytec_1 // "listings1"
    swap
    concat
    // smart_contracts/t_uno/contract.algo.ts:289
    // const value = this.freeAcessTicketlisings(key).value.copy();
    dup
    box_get
    assert // Box must have value
    // smart_contracts/t_uno/contract.algo.ts:292
    // quantity: new arc4.UintN64(value.quantity.native + quantity.native),
    dup
    intc_1 // 0
    extract_uint64
    frame_dig -3
    btoi
    +
    itob
    // smart_contracts/t_uno/contract.algo.ts:293
    // unitaryPrice: value.unitaryPrice
    swap
    extract 8 8 // on error: Index access is out of bounds
    // smart_contracts/t_uno/contract.algo.ts:291-294
    // this.freeAcessTicketlisings(key).value = new FreeAccessTicketValue({
    //   quantity: new arc4.UintN64(value.quantity.native + quantity.native),
    //   unitaryPrice: value.unitaryPrice
    // });
    concat
    box_put
    retsub


// smart_contracts/t_uno/contract.algo.ts::TicketingPlatform.buy(asset: uint64, buyPay: uint64) -> void:
buy:
    // smart_contracts/t_uno/contract.algo.ts:301-302
    // @arc4.abimethod()
    // public buy(asset: Asset, buyPay: gtxn.PaymentTxn): void {
    proto 2 0
    // smart_contracts/t_uno/contract.algo.ts:305
    // asset: new arc4.UintN64(asset.id)
    frame_dig -2
    itob
    // smart_contracts/t_uno/contract.algo.ts:75
    // assignedTicketlistings = BoxMap<AssignedTicketKey, AssignedTicketValue>({keyPrefix: 'listings'});
    bytec_0 // "listings"
    swap
    concat
    dupn 2
    // smart_contracts/t_uno/contract.algo.ts:308
    // assert(this.assignedTicketlistings(key).exists, 'Listing for given asset does not exist');
    box_len
    bury 1
    assert // Listing for given asset does not exist
    // smart_contracts/t_uno/contract.algo.ts:312
    // const owner = this.assignedTicketlistings(key).value.owner;
    dup
    box_get
    assert // Box must have value
    extract 0 32 // on error: Index access is out of bounds
    dup
    uncover 2
    // smart_contracts/t_uno/contract.algo.ts:313
    // const price = this.assignedTicketlistings(key).value.unitaryPrice;
    box_get
    assert // Box must have value
    // smart_contracts/t_uno/contract.algo.ts:316
    // assert(buyPay.amount >= price.native, 'Insufficient payment');
    frame_dig -1
    gtxns Amount
    swap
    // smart_contracts/t_uno/contract.algo.ts:313
    // const price = this.assignedTicketlistings(key).value.unitaryPrice;
    pushint 32 // 32
    // smart_contracts/t_uno/contract.algo.ts:316
    // assert(buyPay.amount >= price.native, 'Insufficient payment');
    extract_uint64
    dup2
    >=
    assert // Insufficient payment
    // smart_contracts/t_uno/contract.algo.ts:319
    // const change: uint64 = buyPay.amount - price.native;
    -
    dup
    cover 2
    // smart_contracts/t_uno/contract.algo.ts:322
    // assert(buyPay.receiver === owner.native, 'Pay receiver must be owner of the listing');
    frame_dig -1
    gtxns Receiver
    uncover 2
    ==
    assert // Pay receiver must be owner of the listing
    // smart_contracts/t_uno/contract.algo.ts:327-332
    // itxn.assetTransfer({
    //   xferAsset: asset,
    //   assetReceiver: Txn.sender,
    //   assetAmount: 1,
    //   fee: 0
    // }).submit()
    itxn_begin
    // smart_contracts/t_uno/contract.algo.ts:329
    // assetReceiver: Txn.sender,
    txn Sender
    // smart_contracts/t_uno/contract.algo.ts:330
    // assetAmount: 1,
    intc_0 // 1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig -2
    itxn_field XferAsset
    // smart_contracts/t_uno/contract.algo.ts:327-332
    // itxn.assetTransfer({
    //   xferAsset: asset,
    //   assetReceiver: Txn.sender,
    //   assetAmount: 1,
    //   fee: 0
    // }).submit()
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/t_uno/contract.algo.ts:331
    // fee: 0
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/t_uno/contract.algo.ts:327-332
    // itxn.assetTransfer({
    //   xferAsset: asset,
    //   assetReceiver: Txn.sender,
    //   assetAmount: 1,
    //   fee: 0
    // }).submit()
    itxn_submit
    // smart_contracts/t_uno/contract.algo.ts:335
    // if(change>0) {
    bz buy_after_if_else@4
    // smart_contracts/t_uno/contract.algo.ts:336-341
    // itxn.payment({
    //   sender: owner.native,
    //   receiver: Txn.sender,
    //   amount: change,
    //   fee:0
    // }).submit()
    itxn_begin
    // smart_contracts/t_uno/contract.algo.ts:338
    // receiver: Txn.sender,
    txn Sender
    frame_dig 2
    itxn_field Amount
    itxn_field Receiver
    frame_dig 1
    itxn_field Sender
    // smart_contracts/t_uno/contract.algo.ts:336-341
    // itxn.payment({
    //   sender: owner.native,
    //   receiver: Txn.sender,
    //   amount: change,
    //   fee:0
    // }).submit()
    intc_0 // 1
    itxn_field TypeEnum
    // smart_contracts/t_uno/contract.algo.ts:340
    // fee:0
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/t_uno/contract.algo.ts:336-341
    // itxn.payment({
    //   sender: owner.native,
    //   receiver: Txn.sender,
    //   amount: change,
    //   fee:0
    // }).submit()
    itxn_submit

buy_after_if_else@4:
    // smart_contracts/t_uno/contract.algo.ts:345-350
    // itxn.payment({
    //   sender: Global.currentApplicationAddress,
    //   receiver: owner.native,
    //   amount: this.listingBoxMbr(),
    //   fee: 0
    // }).submit();
    itxn_begin
    // smart_contracts/t_uno/contract.algo.ts:346
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/t_uno/contract.algo.ts:80-82
    // 2_500 + (
    //   4_00 * 48
    // )
    intc_3 // 21700
    itxn_field Amount
    frame_dig 1
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/t_uno/contract.algo.ts:345-350
    // itxn.payment({
    //   sender: Global.currentApplicationAddress,
    //   receiver: owner.native,
    //   amount: this.listingBoxMbr(),
    //   fee: 0
    // }).submit();
    intc_0 // 1
    itxn_field TypeEnum
    // smart_contracts/t_uno/contract.algo.ts:349
    // fee: 0
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/t_uno/contract.algo.ts:345-350
    // itxn.payment({
    //   sender: Global.currentApplicationAddress,
    //   receiver: owner.native,
    //   amount: this.listingBoxMbr(),
    //   fee: 0
    // }).submit();
    itxn_submit
    // smart_contracts/t_uno/contract.algo.ts:353
    // this.assignedTicketlistings(key).delete();
    frame_dig 0
    box_del
    pop
    retsub


// smart_contracts/t_uno/contract.algo.ts::TicketingPlatform.buyFreeAccessTicket(asset: uint64, owner: bytes, nonce: bytes, quantity: bytes, payment: uint64) -> void:
buyFreeAccessTicket:
    // smart_contracts/t_uno/contract.algo.ts:357
    // public buyFreeAccessTicket(asset: Asset, owner: arc4.Address, nonce: arc4.UintN64, quantity: arc4.UintN64, payment: gtxn.PaymentTxn): void {
    proto 5 0
    // smart_contracts/t_uno/contract.algo.ts:360
    // asset: new arc4.UintN64(asset.id),
    frame_dig -5
    itob
    // smart_contracts/t_uno/contract.algo.ts:359-363
    // const key = new FreeAccessTicketKey({
    //   asset: new arc4.UintN64(asset.id),
    //   owner: owner,
    //   nonce: nonce
    // });
    frame_dig -4
    concat
    frame_dig -3
    concat
    // smart_contracts/t_uno/contract.algo.ts:76
    // freeAcessTicketlisings = BoxMap<FreeAccessTicketKey, FreeAccessTicketValue>({keyPrefix: 'listings1'});
    bytec_1 // "listings1"
    swap
    concat
    // smart_contracts/t_uno/contract.algo.ts:365
    // assert(this.freeAcessTicketlisings(key).exists);
    dup
    box_len
    bury 1
    assert
    // smart_contracts/t_uno/contract.algo.ts:367
    // const value = this.freeAcessTicketlisings(key).value.copy();
    dup
    box_get
    assert // Box must have value
    // smart_contracts/t_uno/contract.algo.ts:369
    // assert(payment.receiver===owner.native);
    frame_dig -1
    gtxns Receiver
    frame_dig -4
    ==
    assert
    // smart_contracts/t_uno/contract.algo.ts:371
    // const amountToPay = new arc4.UintN64(quantity.native * value.unitaryPrice.native);
    frame_dig -2
    btoi
    dig 1
    extract 8 8 // on error: Index access is out of bounds
    dig 2
    pushint 8 // 8
    extract_uint64
    dig 2
    *
    itob
    // smart_contracts/t_uno/contract.algo.ts:373
    // assert(payment.amount===amountToPay.native);
    frame_dig -1
    gtxns Amount
    swap
    btoi
    ==
    assert
    // smart_contracts/t_uno/contract.algo.ts:375-380
    // itxn.assetTransfer({
    //   assetSender: owner.native,
    //   assetReceiver: Txn.sender,
    //   assetAmount: quantity.native,
    //   xferAsset: asset
    // }).submit();
    itxn_begin
    // smart_contracts/t_uno/contract.algo.ts:377
    // assetReceiver: Txn.sender,
    txn Sender
    frame_dig -5
    itxn_field XferAsset
    dig 2
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig -4
    itxn_field AssetSender
    // smart_contracts/t_uno/contract.algo.ts:375-380
    // itxn.assetTransfer({
    //   assetSender: owner.native,
    //   assetReceiver: Txn.sender,
    //   assetAmount: quantity.native,
    //   xferAsset: asset
    // }).submit();
    intc_2 // 4
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/t_uno/contract.algo.ts:384
    // quantity: new arc4.UintN64(value.quantity.native - quantity.native)
    uncover 2
    intc_1 // 0
    extract_uint64
    uncover 2
    -
    itob
    // smart_contracts/t_uno/contract.algo.ts:382-385
    // this.freeAcessTicketlisings(key).value = new FreeAccessTicketValue({
    //   unitaryPrice: value.unitaryPrice,
    //   quantity: new arc4.UintN64(value.quantity.native - quantity.native)
    // })
    swap
    concat
    box_put
    retsub


// smart_contracts/t_uno/contract.algo.ts::TicketingPlatform.withdrawAsset(asset: uint64) -> void:
withdrawAsset:
    // smart_contracts/t_uno/contract.algo.ts:391-392
    // @arc4.abimethod()
    // public withdrawAsset(asset: Asset):void {
    proto 1 0
    // smart_contracts/t_uno/contract.algo.ts:395
    // asset: new arc4.UintN64(asset.id),
    frame_dig -1
    itob
    // smart_contracts/t_uno/contract.algo.ts:75
    // assignedTicketlistings = BoxMap<AssignedTicketKey, AssignedTicketValue>({keyPrefix: 'listings'});
    bytec_0 // "listings"
    swap
    concat
    // smart_contracts/t_uno/contract.algo.ts:399
    // assert(this.assignedTicketlistings(key).exists, 'No listing exists for given asset');
    dup
    box_len
    bury 1
    assert // No listing exists for given asset
    // smart_contracts/t_uno/contract.algo.ts:400
    // const owner = this.assignedTicketlistings(key).value.owner.native;
    dup
    box_get
    assert // Box must have value
    extract 0 32 // on error: Index access is out of bounds
    // smart_contracts/t_uno/contract.algo.ts:403
    // assert(Txn.sender===owner, 'Only owner can withdraw assets');
    txn Sender
    dig 1
    ==
    assert // Only owner can withdraw assets
    // smart_contracts/t_uno/contract.algo.ts:406-410
    // itxn.assetTransfer({
    //   assetReceiver: owner,
    //   xferAsset: asset,
    //   assetAmount: 1
    // }).submit();
    itxn_begin
    // smart_contracts/t_uno/contract.algo.ts:409
    // assetAmount: 1
    intc_0 // 1
    itxn_field AssetAmount
    frame_dig -1
    itxn_field XferAsset
    dup
    itxn_field AssetReceiver
    // smart_contracts/t_uno/contract.algo.ts:406-410
    // itxn.assetTransfer({
    //   assetReceiver: owner,
    //   xferAsset: asset,
    //   assetAmount: 1
    // }).submit();
    intc_2 // 4
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/t_uno/contract.algo.ts:414
    // this.assignedTicketlistings(key).delete();
    swap
    box_del
    pop
    // smart_contracts/t_uno/contract.algo.ts:417-420
    // itxn.payment({
    //   receiver: owner,
    //   amount: this.listingBoxMbr()
    // }).submit()
    itxn_begin
    // smart_contracts/t_uno/contract.algo.ts:80-82
    // 2_500 + (
    //   4_00 * 48
    // )
    intc_3 // 21700
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/t_uno/contract.algo.ts:417-420
    // itxn.payment({
    //   receiver: owner,
    //   amount: this.listingBoxMbr()
    // }).submit()
    intc_0 // 1
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    retsub


// smart_contracts/t_uno/contract.algo.ts::TicketingPlatform.withdrawFreeAccessTickets(asset: uint64, quantity: bytes, nonce: bytes) -> void:
withdrawFreeAccessTickets:
    // smart_contracts/t_uno/contract.algo.ts:426-427
    // @arc4.abimethod()
    // public withdrawFreeAccessTickets(asset: Asset, quantity: arc4.UintN64, nonce: arc4.UintN64): void {
    proto 3 0
    // smart_contracts/t_uno/contract.algo.ts:430
    // asset: new arc4.UintN64(asset.id),
    frame_dig -3
    itob
    // smart_contracts/t_uno/contract.algo.ts:431
    // owner: new arc4.Address(Txn.sender),
    txn Sender
    // smart_contracts/t_uno/contract.algo.ts:429-433
    // const key = new FreeAccessTicketKey({
    //   asset: new arc4.UintN64(asset.id),
    //   owner: new arc4.Address(Txn.sender),
    //   nonce: nonce
    // })
    concat
    frame_dig -1
    concat
    // smart_contracts/t_uno/contract.algo.ts:76
    // freeAcessTicketlisings = BoxMap<FreeAccessTicketKey, FreeAccessTicketValue>({keyPrefix: 'listings1'});
    bytec_1 // "listings1"
    swap
    concat
    dupn 2
    // smart_contracts/t_uno/contract.algo.ts:435
    // assert(this.freeAcessTicketlisings(key).exists);
    box_len
    bury 1
    assert
    // smart_contracts/t_uno/contract.algo.ts:437
    // const value = this.freeAcessTicketlisings(key).value.copy()
    box_get
    swap
    dup
    cover 2
    cover 3
    assert // Box must have value
    // smart_contracts/t_uno/contract.algo.ts:439-443
    // itxn.assetTransfer({
    //   xferAsset: asset,
    //   assetReceiver: Txn.sender,
    //   assetAmount: quantity.native
    // }).submit();
    itxn_begin
    // smart_contracts/t_uno/contract.algo.ts:441
    // assetReceiver: Txn.sender,
    txn Sender
    // smart_contracts/t_uno/contract.algo.ts:442
    // assetAmount: quantity.native
    frame_dig -2
    btoi
    dup
    itxn_field AssetAmount
    swap
    itxn_field AssetReceiver
    frame_dig -3
    itxn_field XferAsset
    // smart_contracts/t_uno/contract.algo.ts:439-443
    // itxn.assetTransfer({
    //   xferAsset: asset,
    //   assetReceiver: Txn.sender,
    //   assetAmount: quantity.native
    // }).submit();
    intc_2 // 4
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/t_uno/contract.algo.ts:445
    // if(value.quantity.native - quantity.native>0) {
    swap
    intc_1 // 0
    extract_uint64
    swap
    -
    dup
    cover 2
    bz withdrawFreeAccessTickets_else_body@3
    // smart_contracts/t_uno/contract.algo.ts:448
    // unitaryPrice: value.unitaryPrice,
    frame_dig 0
    extract 8 8 // on error: Index access is out of bounds
    // smart_contracts/t_uno/contract.algo.ts:449
    // quantity: new arc4.UintN64(value.quantity.native - quantity.native)
    frame_dig 1
    itob
    // smart_contracts/t_uno/contract.algo.ts:447-450
    // this.freeAcessTicketlisings(key).value = new FreeAccessTicketValue({
    //   unitaryPrice: value.unitaryPrice,
    //   quantity: new arc4.UintN64(value.quantity.native - quantity.native)
    // })
    swap
    concat
    box_put
    retsub

withdrawFreeAccessTickets_else_body@3:
    // smart_contracts/t_uno/contract.algo.ts:454
    // this.freeAcessTicketlisings(key).delete();
    box_del
    pop
    retsub


// smart_contracts/t_uno/contract.algo.ts::TicketingPlatform.buyWithAssets(asset: uint64, xfer: uint64) -> void:
buyWithAssets:
    // smart_contracts/t_uno/contract.algo.ts:459-460
    // @arc4.abimethod()
    // public buyWithAssets(asset: Asset, xfer: gtxn.AssetTransferTxn): void {
    proto 2 0
    // smart_contracts/t_uno/contract.algo.ts:463
    // asset: new arc4.UintN64(asset.id)
    frame_dig -2
    itob
    // smart_contracts/t_uno/contract.algo.ts:75
    // assignedTicketlistings = BoxMap<AssignedTicketKey, AssignedTicketValue>({keyPrefix: 'listings'});
    bytec_0 // "listings"
    swap
    concat
    // smart_contracts/t_uno/contract.algo.ts:466
    // const owner = this.assignedTicketlistings(key).value.owner
    dup
    box_get
    assert // Box must have value
    extract 0 32 // on error: Index access is out of bounds
    // smart_contracts/t_uno/contract.algo.ts:472
    // assert(xfer.assetSender===Txn.sender);
    frame_dig -1
    gtxns AssetSender
    txn Sender
    ==
    assert
    // smart_contracts/t_uno/contract.algo.ts:475
    // assert(xfer.assetReceiver===Global.currentApplicationAddress);
    frame_dig -1
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert
    // smart_contracts/t_uno/contract.algo.ts:478
    // assert(xfer.assetAmount>0);
    frame_dig -1
    gtxns AssetAmount
    assert
    // smart_contracts/t_uno/contract.algo.ts:481-486
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   assetSender: owner.native,
    //   assetAmount: 1,
    //   xferAsset: asset
    // }).submit();
    itxn_begin
    // smart_contracts/t_uno/contract.algo.ts:482
    // assetReceiver: Txn.sender,
    txn Sender
    frame_dig -2
    itxn_field XferAsset
    // smart_contracts/t_uno/contract.algo.ts:484
    // assetAmount: 1,
    intc_0 // 1
    itxn_field AssetAmount
    dig 1
    itxn_field AssetSender
    itxn_field AssetReceiver
    // smart_contracts/t_uno/contract.algo.ts:481-486
    // itxn.assetTransfer({
    //   assetReceiver: Txn.sender,
    //   assetSender: owner.native,
    //   assetAmount: 1,
    //   xferAsset: asset
    // }).submit();
    intc_2 // 4
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    // smart_contracts/t_uno/contract.algo.ts:491
    // const res = this.assignedTicketlistings(key).delete();
    swap
    box_del
    // smart_contracts/t_uno/contract.algo.ts:492
    // assert(res===true);
    intc_0 // 1
    ==
    assert
    // smart_contracts/t_uno/contract.algo.ts:495-500
    // itxn.payment({
    //   sender: Global.currentApplicationAddress,
    //   receiver: owner.native,
    //   amount: this.listingBoxMbr(),
    //   fee: 0
    // }).submit();
    itxn_begin
    // smart_contracts/t_uno/contract.algo.ts:496
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/t_uno/contract.algo.ts:80-82
    // 2_500 + (
    //   4_00 * 48
    // )
    intc_3 // 21700
    itxn_field Amount
    itxn_field Sender
    itxn_field Receiver
    // smart_contracts/t_uno/contract.algo.ts:495-500
    // itxn.payment({
    //   sender: Global.currentApplicationAddress,
    //   receiver: owner.native,
    //   amount: this.listingBoxMbr(),
    //   fee: 0
    // }).submit();
    intc_0 // 1
    itxn_field TypeEnum
    // smart_contracts/t_uno/contract.algo.ts:499
    // fee: 0
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/t_uno/contract.algo.ts:495-500
    // itxn.payment({
    //   sender: Global.currentApplicationAddress,
    //   receiver: owner.native,
    //   amount: this.listingBoxMbr(),
    //   fee: 0
    // }).submit();
    itxn_submit
    retsub


// smart_contracts/t_uno/contract.algo.ts::TicketingPlatform.isOptedInTo(asset: uint64) -> uint64:
isOptedInTo:
    // smart_contracts/t_uno/contract.algo.ts:507
    // public isOptedInTo(asset: Asset): boolean {
    proto 1 1
    // smart_contracts/t_uno/contract.algo.ts:508
    // return Global.currentApplicationAddress.isOptedIn(asset);
    global CurrentApplicationAddress
    frame_dig -1
    asset_holding_get AssetBalance
    bury 1
    retsub
